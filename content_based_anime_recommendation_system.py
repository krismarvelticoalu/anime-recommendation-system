# -*- coding: utf-8 -*-
"""content-based-anime-recommendation-system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RG6hDnyyvo4AclBWDTPPfbbcYkilwtJy

Import library yang diperlukan
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

"""Mengupload file kaggle.json untuk kebutuhan download dataset melalui Kaggle API"""

from google.colab import files
files.upload()

"""Download dataset dari kaggle and ekstrak file zip dataset"""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/

!chmod 600 ~/.kaggle/kaggle.json
!kaggle datasets download -d hernan4444/anime-recommendation-database-2020

!unzip /content/anime-recommendation-database-2020.zip

"""Memuat dataset dari setiap file anime.csv ke dalam pandas dataframe"""

anime = pd.read_csv('/content/anime.csv')

"""Mengatur agar tidak ada batasan jumlah kolom yang ditampilkan"""

pd.set_option('display.max_columns', None)

"""Menampilkan informasi mengenai dataframe anime"""

anime.info()

"""Menampilkan dataframe anime"""

anime

"""Mengecek missing value pada dataframe anime"""

anime.isnull().sum()

"""Mengecek data duplikat pada dataframe anime"""

anime.duplicated().sum()

"""Menghilangkan data dengan nilai Unknown dari data genre"""

anime = anime[anime['Genres'] != 'Unknown']
anime

"""Menampilkan visualisasi distribusi rating anime"""

anime_rating = anime['Rating'][anime['Rating'] != 'Unknown'].value_counts().sort_values()

plt.figure(figsize=(7, 7))

plt.title("Anime Rating Distribution")
bars = plt.barh(y=anime_rating.index, width=anime_rating.values, color='#004D99')
plt.bar_label(bars, padding=-30, color='white')
plt.ylabel("Number of Anime")
plt.show()

"""Menampilkan visualisasi distribusi tipe anime"""

anime_type = anime['Type'][anime['Type'] != 'Unknown'].value_counts().sort_values()

plt.figure(figsize=(7, 7))

plt.title("Anime Type Distribution")
bars = plt.bar(x=anime_type.index, height=anime_type.values, color='#004D99')
plt.bar_label(bars, padding=-20, color='white')
plt.ylabel("Number of Anime")
plt.show()

"""Menampilkan visualisasi distribusi sumber adaptasi anime"""

anime_source = anime['Source'][anime['Source'] != 'Unknown'].value_counts().sort_values()

plt.figure(figsize=(7, 7))

plt.title("Anime Source Distribution")
bars = plt.barh(y=anime_source.index, width=anime_source.values, color='#004D99')
plt.bar_label(bars, padding=5, color='#004D99')
plt.ylabel("Number of Anime")
plt.xticks(range(0, 7000, 1000))
plt.show()

"""Menyimpan dataframe anime dengan kolom MAL_ID, Name, Genres"""

all_anime = anime[['MAL_ID', 'Name', 'Genres']]

all_anime

"""Mengurutkan anime berdasarkan MAL_ID

"""

sorted_anime = all_anime.sort_values('MAL_ID', ascending=True)
sorted_anime

"""Mengecek berapa jumlah fix_anime"""

len(sorted_anime.MAL_ID.unique())

"""Memetakan setiap anime dengan 1 genre saja"""

sorted_anime['Genres'] = sorted_anime['Genres'].apply(lambda x: x.split(', ')[0])
sorted_anime['Genres']

"""Mengecek genre yang unik"""

sorted_anime.Genres.unique()

"""Mengonversi data series ‘anime_id’, ‘Name’, ‘Genres’ menjadi dalam bentuk list"""

# Mengonversi data series MAL_ID menjadi dalam bentuk list
mal_id = sorted_anime['MAL_ID'].tolist()

# Mengonversi data series ‘Name’ menjadi dalam bentuk list
anime_name = sorted_anime['Name'].tolist()

# Mengonversi data series ‘Genres’ menjadi dalam bentuk list
anime_genre = sorted_anime['Genres'].tolist()

print(len(mal_id))
print(len(anime_name))
print(len(anime_genre))

"""Membuat Dataframe baru dengan nama kolom id, anime_name, dan genre"""

anime_new = pd.DataFrame({
    'id': mal_id,
    'anime_name': anime_name,
    'genre': anime_genre
})
anime_new

"""Assign dataframe anime_new ke dalam variabel data kemudian cek 5 sampelnya"""

data = anime_new
data.sample(5)

"""Menerapkan TF-IDF Vectorizer terhadap data genre"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer(token_pattern=r'(?u)\b\w\w+\s*-*\w+\s*\w+\b')

# Melakukan perhitungan idf pada data cuisine
tf.fit(data['genre'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

"""Melakukan fit lalu ditransformasikan ke bentuk matrix dan melihat ukuran matrix tfidf"""

tfidf_matrix = tf.fit_transform(data['genre'])

tfidf_matrix.shape

"""Mengubah vektor tf-idf dalam bentuk matriks menjadi bentuk dense dengan fungsi todense()"""

tfidf_matrix.todense()

"""Membuat dataframe untuk melihat tf-idf matrix"""

# Kolom diisi dengan genre
# Baris diisi dengan nama anime

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=data.anime_name
).sample(10, axis=0)

"""Menghitung cosine similarity pada matrix tf-idf"""

from sklearn.metrics.pairwise import cosine_similarity

cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

"""Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama anime kemudian melihat similarity matrix pada setiap anime"""

cosine_sim_df = pd.DataFrame(cosine_sim, index=data['anime_name'], columns=data['anime_name'])
print('Shape:', cosine_sim_df.shape)

cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""Mendefinisikan fungsi untuk merekomendasikan anime yang mirip berdasarkan nama anime"""

def anime_recommendations(nama_anime, similarity_data=cosine_sim_df, items=data[['anime_name', 'genre']], k=5):
    """
    Rekomendasi anime berdasarkan kemiripan dataframe

    Parameter:
    ---
    nama_anime : tipe data string (str)
                Nama anime (index kemiripan dataframe)
    similarity_data : tipe data pd.DataFrame (object)
                      Kesamaan dataframe, simetrik, dengan anime sebagai
                      indeks dan kolom
    items : tipe data pd.DataFrame (object)
            Mengandung kedua nama dan fitur lainnya yang digunakan untuk mendefinisikan kemiripan
    k : tipe data integer (int)
        Banyaknya jumlah rekomendasi yang diberikan
    ---


    Pada index ini, kita mengambil k dengan nilai similarity terbesar
    pada index matrix yang diberikan (i).
    """


    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,nama_anime].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Drop nama_anime agar nama anime yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(nama_anime, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""Melihat data anime Slam Dunk"""

slam_dunk = data[data.anime_name.eq('Slam Dunk')]

slam_dunk_genre = slam_dunk['genre'].values[0]

slam_dunk

"""Mendapatkan 10 rekomendasi anime yang mirip dengan Slam Dunk"""

k = 10
recommendations_df = anime_recommendations('Slam Dunk', k=k)
recommendations_df

"""Menentukan rekomendasi yang relevan dan menampilkan jumlah rekomendasi yang relevan"""

rekomendasi_relevan = []
for row in recommendations_df.values:
  if row[1] == slam_dunk_genre:
    rekomendasi_relevan.append(row[0])

print("Jumlah rekomendasi relevan:", len(rekomendasi_relevan))
print(rekomendasi_relevan)

"""Menghitung nilai precision dengan membagi nilai total rekomendasi relevan yang didapat yaitu 72 dengan total rekomendasi yaitu 100"""

total_rekomendasi_relevan = len(rekomendasi_relevan)
total_rekomendasi = k

precision = total_rekomendasi_relevan / total_rekomendasi
print("Nilai precision:", precision)